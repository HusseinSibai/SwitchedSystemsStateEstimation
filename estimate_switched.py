import math
import control as ctrl
import numpy as np
import pylab as pl
import matplotlib.patches as mpatches
import random
from math import exp
from scipy.integrate import odeint
from GlycemicControlpoly import Glycemic, Glycemic1,Glycemic2, Glycemic3, Glycemic4,Glycemic5, Glycemic6, Glycemic7, Glycemic8
import slycot
import scipy.io as sio

from grid import Hyperrect

class DetectAlgo:
    "Class for a detection algorithm"

    def __init__(self,T,alpha,K,x0,d0, Dmax, N, sys = [],L = [], system_type = 0):
        """
        T:time period
        alpha: exponential rate
        K: initial rectangle [ll,tr]
        d0: initial delta
        x0: initial state
        L: list of Lipshitz constants of the different modes; for linear modes, it is now computed as Frobenius norm of A, for nonlinear ones estimated by sampling.
        sys: list of the possible modes of the system
        Dmax: the maximum separation between the modes as defined in the paper in Section 2, it is estimate here locally at each sampling time, so this value is being ignored for now
        N: number of modes to be tracked (\hat N in the paper)
        system_type: linear switched or the glycemic control switched system (these are the considered for now, can be extended to other systems)
        """
        self.T = T
        self.alpha = alpha
        self.K = Hyperrect(K[0],K[1])
        self.d0 = d0
        self.x0 = x0
        self.L = list(L)
        self.sys = list(sys)
        self.Dmax = Dmax
        self.N = N
        self.system_type = system_type

    
    def print_function(self):
        print('Printing Detection Algorithm Parameters \n')
        print('Time period (T):',self.T)
        print('alpha (T):',self.alpha)
        
    
    def run(self,iterBound,toplot):
        """This is the function that runs the algorithm
            iterBound is number of iteration to try before giving up
            toplot =  plots the graph
        """
        # detailed algorithm parameters
        simstep = self.T/10.0
        
        system_type = self.system_type
        # These variables are updated as the algorithm runs but the DetectAlgo members are not
        i = 0;          #iteration
        N = self.N # N does not change in the algorithm
        mode = 0 # a valid mode (same as the variable with the same name in the paper)
        x = self.x0     #current state
        t = 0.0;        #current time of actual state
        d = self.d0   #delta (same for all the bounding boxes S)
        S = [self.K] *  N # list of the bounding boxes for each mode tracked (we can create one for all of the modes and translate the states as in the algorithm in the paper but kept like this for simplicity)
        m = [];
        m.extend(range(0, N)) # list containing the indices of the modes being tracked at a given iteration
        L = max(self.L); # the only Lipschitz constant of use in the algorithm is the maximum one
        P = len(self.sys); # total number of possible modes
        Dmax = self.Dmax; # Dmax is being approximated at each iteration
        sigma = 5 #random.randint(1,5) # The current actual mode of the system
        alpha = self.alpha # alpha does not change
        sys = self.sys
        Td = 40 # dwell time
        vT = [x] * N; # a vector containing the states reached by the different tracked modes at a given iteration
        Visited = [0]*len(self.sys) # a vector keeping track of the visited (considered) modes (related to the NextMode() function in the algorithm)
        nextmode_counter = 0; # counter used to decide when to reset the "visited" vector
        
        # Initializing input segment and time horizon for each fragment
        Tseq = np.arange(t,t+self.T,simstep)  # [0,T,simsptep]
        rol = [1]*len(Tseq)
        U = [rol]*self.K.dim
        
        # Estimating the maximum distance between the states generated by any two different modes
        Dmax =0;
        for sys_t_1 in range(0,len(sys)):
            for sys_t_2 in range(sys_t_1 + 1,len(sys)):
                Dmax = max(Dmax,np.linalg.norm(odeint(sys[sys_t_1], x, Tseq)[-1,:] - odeint(sys[sys_t_2], x, Tseq)[-1,:],np.inf))
        
        ############## Algorithm Analysis Variables ##################
        deltamax = d # keeping track of the maximum radius of a bounding box reached (representing the maximum uncertainty in the state)
        numEscapes = 0 # number of times the state escaped all the bounding boxes of the tracked modes
        numSwitches = 0 # number of times the system switched modes
        i_tau = 0; # number of iterations needed to detect the actual mode after the last switch and get delta to be less than d0 (corresponds to Tau_e in the paper)
        max_i_tau = 0; # keeping track of the maximum number of iterations needed to detect the mode and get delta to be less than d0
        tau_achieved = 0; # a boolean variable reperesenting if the condition that the true mode is detected and delta is less than d0 is attained since the last switch.
        #################################################
        
        # a handy constant (L + \alpha)T
        LAT = (L + self.alpha) * self.T
        
        if toplot:
            print('\n grid size =' + str(d*(exp(-LAT))) + '\n')
        
        for j in range(0,N):
            S[j].grid_all(d*(exp(-LAT)))   #Starting construction of C for each S
    
        
        # Initializing colors for plotting
        colormap = pl.cm.Accent  #paired rainbow #BuPu #Accent#Paired #nipy_spectral
        pl.gca().set_color_cycle([colormap(k) for k in np.linspace(0, 0.9, S[0].dim)])
        pl.xlabel('Time $(t)$', fontsize=25)
        pl.ylabel('$x(t), z(t)$', fontsize=30)
        pl.tick_params(axis='both', which='major', labelsize=14)
        

        tv = [0]*N
        yout = [0]*N
        vseq = [0]*N
        last_switch = 0 # the iteration at which the last switch happened
        assumption2_violated = 0; # boolean variable asserted if a switch happens before the true mode is detected or delta is still larger than d0
        while(i<iterBound):
            
            # computing the maximum maximum tau for the analysis of the algorithm, this is independent of the algorithm
            if i_tau == 0:
                tau_achieved = 1;
                if d > self.d0:
                    tau_achieved = 0;
                for r in range(0,N):
                    if (m[r] != sigma - 1) and (m[r]!=-1):
                        tau_achieved =0;
                if tau_achieved == 1:
                    i_tau = i - last_switch;
                    max_i_tau = max(max_i_tau, i_tau)
        
            ###################################################
            # Linear switched system criteria to switch to another mode
            if system_type == 0:
                if i % Td == 0 and tau_achieved:
                    numSwitches = numSwitches + 1
                    sigma = 2#random.randint(1,5)
                    last_switch = i;
                    tau_achieved = 0;
                    i_tau = 0
            ###################################################
            # Glycemic Control system criteria to switch to another mode
            if system_type >= 1:
                G = x[0]
                if sigma == 1 and G >= 4:
                    sigma = 2
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 2 and G <= 4:
                    sigma = 1
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                        tau_achieved = 0;
                        i_tau = 0
                elif sigma == 2 and G >= 8:
                    sigma = 3
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 3 and G >= 8:
                    sigma = 2
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 4 and G >= 4:
                    sigma = 5
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 5 and G <= 4:
                    sigma = 4
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 5 and G >= 8:
                    sigma = 6
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 6 and G <= 8:
                    sigma = 5
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 7 and G >= 4:
                    sigma = 8
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 8 and G <= 4:
                    sigma = 7
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 8 and G >= 8:
                    sigma = 9
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 9 and G <= 8:
                    sigma = 8
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 1 and i >= int(30/self.T):
                    sigma = 4
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 2 and i >= int(30/self.T):
                    sigma = 5
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 3 and i >= int(30/self.T):
                    sigma = 6
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 4 and i >= int(120/self.T):
                    sigma = 7
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 5 and i >= int(120/self.T):
                    sigma = 8
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
                elif sigma == 6 and i >= int(120/self.T):
                    sigma = 9
                    numSwitches = numSwitches + 1
                    last_switch = i;
                    if tau_achieved == 0:
                        assumption2_violated = assumption2_violated + 1;
                    tau_achieved = 0;
                    i_tau = 0
            ####################################################
            stillTracked = 0; # if asserted it means an escape happened, i.e. no bounding box contains the actual state
            stillValid = [0] * N; # vector of boolean values representing the presence of the actual state in each of the bounding boxes corresponding to the tracked modes
            for j in range(0,N):
                if (m[j] != -1 and S[j].contains(x)):
                    stillTracked = 1;
                    stillValid[j] = 1;
                    mode = j;
            if (stillTracked == 0): # there is an escape
                Dmax = 0; # estimate Dmax locally based on the current state
                for sys_t_1 in range(0,len(sys)):
                    for sys_t_2 in range(sys_t_1 + 1,len(sys)):
                        Dmax = max(Dmax,np.linalg.norm(odeint(sys[sys_t_1], x, Tseq)[-1,:] - odeint(sys[sys_t_2], x, Tseq)[-1,:],np.inf))
                # since the computed Dmax is only an estimate, it may be less than the actual Dmax, so
                # it the escaped state may still be outside the newly computed bounding box
                # in our experiments, when we are running the last experiment (the 100 random points for each N)
                # the state escaped the new S, so we increased delta by 2 * Dmax instead of Dmax while it was sufficient for the first two experiments to just increase it by Dmax as in the paper.
                if system_type == 2:
                    d =  2 * Dmax + d; # increase delta, the radius of the bounding boxes
                else:
                    d = Dmax + d;
                deltamax = max(deltamax, d); # for analysis, keep track of the maximum radius (delta) reached
                ll,tr = Hyperrect.MakeBall(vT[mode],d);
                S[mode] = Hyperrect(ll,tr);        # new S, based on a mode that contains the state in the previous iteration, that contains the escaped state
                S[mode].grid_all(d*(exp(-LAT))); # construct a grid (C) on the new S
                q = S[mode].quantize(x); # quantize the state with respect to the new C
                numEscapes = numEscapes + 1; # for analysis, keep track of the number of escapes
            else: # there is no escape
                # measurue/sense current state with respect to C
                q = S[mode].quantize(x) # just quantize with respect to the bounding box that contains the state

            # draw S range
            #for j in range(0,S[mode].dim-2):
            if toplot:
                pl.plot([t, t], [q[0]-d, q[0]+d],'x-', color='deepskyblue',lw=2)
                pl.plot([t, t], [q[1]-d, q[1]+d],'x-', color='orange',lw=2)
                # draw the third dimension for the Glycemic Control system, it is not drawn for the linear system just for clarity of the figure (so, the following "if" condition can be removed)
                if system_type >= 1:
                    pl.plot([t, t], [q[2]-d, q[2]+d],'x-', color='yellow',lw=2)

            
            i=i+1
            d = d * exp(-self.alpha*self.T) # update delta (applies both in the case there is an escape or there is not)
            for r in range(0,N):
                # replace the falsified modes
                if (stillTracked == 0) or (stillValid[r] == 0 and m[r]!=-1):
                    VisitedFull = 1
                    for k in range(0,len(self.sys)):
                        if (Visited[k] == 0):
                            m[r] = k;
                            Visited[k] = 1;
                            VisitedFull = 0
                            break;
    
                    if VisitedFull == 1: # if all the modes are considered
                        if (nextmode_counter + 1) % N != 0: # wait till all the remaining modes other than the actual mode to be falsified
                            nextmode_counter = nextmode_counter + 1
                            m[r] = -1;
                        else: # only the actual mode of the system is left in the vector m representing the tracked modes
                            Visited = [0]*len(self.sys)
                            m[r] = 0
                            Visited[0] = 1
                            VisitedFull = 0
                            nextmode_counter = 0;

                # Construct the bounding boxes S[r]'s for the tracked modes
                if m[r] != -1:
                    [vseq[r], dict] = odeint(self.sys[m[r]], q, Tseq,full_output = True)
                    tv[r] = dict['tcur']
                    vseq[r] = np.transpose(vseq[r])
                    vT[r] = zip(*vseq[r])[-1]
                    ll,tr = Hyperrect.MakeBall(vT[r],d)
                    S[r] = Hyperrect(ll,tr)        # new S
                    S[r].grid_all(d*(exp(-LAT)))   # new C

            if toplot:
                for j in range(0,N): # print the expected state in the next iteration based on the different tracked modes
                    if m[j] != -1:
                        print('\n d= ' + str(d) + ' state = ' + str(vT[j]) + '\n' )

            # this is not part of the algorithm, this is the system evolving
            [xseq, dict] = odeint(self.sys[sigma-1], x, Tseq, full_output = True)
            xseq = np.transpose(xseq)
            tx = dict['tcur']
            x = zip(*xseq)[-1]          #new state
                                
            t = t + self.T
            Tseq = Tseq + self.T
                
            # plot the real trajectory \xi(.), the estimated traj v(.) and the new S
            # for the next T duration
            zseq = 0
            tz = 0
            zseq = vseq[mode];
            tz = tv[mode];
            sigma_t = [sigma] * len(tx);
            mode_t = [m[mode]+1] * len(tx);
            num_of_dim_toplot = 2
            if system_type >= 1:
                num_of_dim_toplot = 3
            if toplot:
                for j in range(0,num_of_dim_toplot):
                    pl.plot(tz, zseq[j, 0:len(tz)], color='violet',lw=2)
                for j in range(0,num_of_dim_toplot):
                    pl.plot(tx, xseq[j, 0:len(tx)], '--', color='g',lw=2)
                for j in range(0,num_of_dim_toplot):
                    pl.plot(tx, np.dot(2.5,sigma_t), color='k', lw=2)
                for j in range(0,num_of_dim_toplot):
                    pl.plot(tx, np.dot(2.5,mode_t), color='r', lw=2)
                
    
        if toplot:
            # draw S range
            for j in range(0,S[mode].dim-3):
                pl.plot(t, x[j], 'x-', lw=2)
            pl.xlim(-0.2,t+0.2)
            pl.plot([], [], color='red', label='$\hat \sigma(t)$')
            pl.plot([], [], color='black', label='$\sigma(t)$')
            pl.legend(prop={'size':25})
            axes = pl.gca()
            if system_type == 0:
                axes.set_ylim([-5,15])
            pl.show()
        
        return [ i, t, d, deltamax,numSwitches,numEscapes,Dmax, max_i_tau, assumption2_violated]


# The rest of the file sets up two experiments

def sys8(x,t):
    xd = [[0],[0],[0],[0],[0]];
    x1 = x[0]; x2 = x[1]; x3 = x[2]; x4 = x[3]; x5 = x[4];
    xd[0] = -0.8047*x1 + 8.7420*x2 - 2.4591*x3 - 8.2714*x4 - 1.8640*x5 + 0.0845
    xd[1] = -8.6329*x1 - 0.5860*x2 - 2.1006*x3 + 3.6035*x4 - 1.8423*x5
    xd[2] = 2.4511*x1 + 2.2394*x2 - 0.7538*x3 - 3.6934*x4 + 2.4585*x5
    xd[3] = 8.3858*x1 - 3.1739*x2 + 3.7822*x3 - 0.6249*x4 + 1.8829*x5
    xd[4] = 1.8302*x1 + 1.9869*x2 - 2.4539*x3 - 1.7726*x4 - 0.7911*x5 + 0.7342
    return xd

A = [[-0.8047 , 8.7420, - 2.4591, - 8.2714, - 1.8640],
    [-8.6329,  - 0.5860, - 2.1006, + 3.6035, - 1.8423],
    [2.4511, + 2.2394, - 0.7538, - 3.6934, + 2.4585],
    [8.3858, - 3.1739, + 3.7822, - 0.6249, + 1.8829],
    [1.8302, + 1.9869, - 2.4539, - 1.7726, - 0.7911]]
L8 = np.linalg.norm(A)
print "L8",L8

def sys9(x,t):
    xd = [[0],[0],[0],[0],[0]];
    x1 = x[0]; x2 = x[1]; x3 = x[2]; x4 = x[3]; x5 = x[4];
    xd[0] = -0.8316*x1 + 8.7658*x2 - 2.4744*x3 - 8.2608*x4 - 1.9033*x5 + -0.0845
    xd[1] = -0.8316*x1 - 0.5860*x2 - 2.1006*x3 + 3.6035*x4 - 1.8423*x5
    xd[2] = 2.4511*x1 + 2.2394*x2 - 0.7538*x3 - 3.6934*x4 + 2.4585*x5
    xd[3] = 8.3858*x1 - 3.1739*x2 + 3.7822*x3 - 0.6249*x4 + 1.8829*x5
    xd[4] = 1.5964*x1 + 2.1936*x2 - 2.5872*x3 - 1.6812*x4 - 1.1324*x5 + -0.7342
    return xd

A = [[-0.8316, + 8.7658, - 2.4744, - 8.2608, - 1.9033],
    [-0.8316, - 0.5860, - 2.1006, + 3.6035, - 1.8423],
    [2.4511, + 2.2394, - 0.7538, - 3.6934, + 2.4585],
    [8.3858, - 3.1739, + 3.7822, - 0.6249, + 1.8829],
    [1.5964, + 2.1936, - 2.5872, - 1.6812, - 1.1324]]

L9 = np.linalg.norm(A)
print "L9",L9

def sys10(x,t):
    xd = [[0],[0],[0],[0],[0]];
    x1 = x[0]; x2 = x[1]; x3 = x[2]; x4 = x[3]; x5 = x[4];
    xd[0] = -0.9275*x1 + 8.8628*x2 - 2.5428*x3 - 8.2329*x4 - 2.0324*x5 + 0.0845
    xd[1] = -0.8316*x1 - 0.5860*x2 - 2.1006*x3 + 3.6035*x4 - 1.8423*x5
    xd[2] = 2.4511*x1 + 2.2394*x2 - 0.7538*x3 - 3.6934*x4 + 2.4585*x5
    xd[3] = 8.3858*x1 - 3.1739*x2 + 3.7822*x3 - 0.6249*x4 + 1.8829*x5
    xd[4] = 0.7635*x1 + 3.0357*x2 - 3.1814*x3 - 1.4388*x4 - 2.2538*x5 + 0.7342
    return xd

A = [[-0.9275, + 8.8628, - 2.5428, - 8.2329, - 2.0324],
    [-0.8316, - 0.5860, - 2.1006, + 3.6035, - 1.8423],
    [2.4511, + 2.2394, - 0.7538, - 3.6934, + 2.4585],
    [8.3858, - 3.1739, + 3.7822, - 0.6249, + 1.8829],
    [0.7635, + 3.0357, - 3.1814, - 1.4388, - 2.2538]]

L10 = np.linalg.norm(A)
print "L10",L10

def sys11(x,t):
    xd = [[0],[0],[0],[0],[0]];
    x1 = x[0]; x2 = x[1]; x3 = x[2]; x4 = x[3]; x5 = x[4];
    xd[0] = -1.0145*x1 + 8.9701*x2 - 2.6207*x3 - 8.2199*x4 - 2.1469*x5 + 0.0845
    xd[1] = -0.8316*x1 - 0.5860*x2 - 2.1006*x3 + 3.6035*x4 - 1.8423*x5
    xd[2] = 2.4511*x1 + 2.2394*x2 - 0.7538*x3 - 3.6934*x4 + 2.4585*x5
    xd[3] = 8.3858*x1 - 3.1739*x2 + 3.7822*x3 - 0.6249*x4 + 1.8829*x5
    xd[4] = 0.0076*x1 + 3.9682*x2 - 3.8578*x3 - 1.3253*x4 - 3.2477*x5 + -0.7342
    return xd

A = [[-1.0145, + 8.9701, - 2.6207, - 8.2199, - 2.1469],
    [-0.8316, - 0.5860, - 2.1006, + 3.6035, - 1.8423],
    [2.4511, + 2.2394, - 0.7538, - 3.6934, + 2.4585],
    [8.3858, - 3.1739, + 3.7822, - 0.6249, + 1.8829],
    [0.0076, + 3.9682, - 3.8578, - 1.3253, - 3.2477]]

L11 = np.linalg.norm(A)
print "L11",L11

def sys12(x,t):
    xd = [[0],[0],[0],[0],[0]];
    x1 = x[0]; x2 = x[1]; x3 = x[2]; x4 = x[3]; x5 = x[4];
    xd[0] =  -1.4021*x1 + 10.1647*x2 - 3.3937*x3 - 8.5139*x4 - 2.9602*x5 + 0.0845
    xd[1] = -0.8316*x1 - 0.5860*x2 - 2.1006*x3 + 3.6035*x4 - 1.8423*x5
    xd[2] = 2.4511*x1 + 2.2394*x2 - 0.7538*x3 - 3.6934*x4 + 2.4585*x5
    xd[3] = 8.3858*x1 - 3.1739*x2 + 3.7822*x3 - 0.6249*x4 + 1.8829*x5
    xd[4] = -3.3585*x1 + 14.3426*x2 - 10.5703*x3 - 3.8785*x4 - 10.3111*x5 + 0.7342
    return xd

A = [[-1.4021, + 10.1647, - 3.3937, - 8.5139, - 2.9602],
    [-0.8316, - 0.5860, - 2.1006, + 3.6035, - 1.8423],
    [2.4511, + 2.2394, - 0.7538, - 3.6934, + 2.4585],
    [8.3858, - 3.1739, + 3.7822, - 0.6249, + 1.8829],
    [-3.3585, + 14.3426, - 10.5703, - 3.8785, - 10.3111]]
L12 = np.linalg.norm(A)
print "L12",L12



# to generate figure 2 (center) in the paper, uncomment the following and run the python code
'''Dalg = DetectAlgo(1,1,[[-2,-0.5,-0.1],[2,5,1]],[1, 0, 0.05], 2, 0.5, 1, [Glycemic,Glycemic1, Glycemic2,Glycemic3,Glycemic4,Glycemic5,Glycemic6,Glycemic7,Glycemic8],[3,3,3,3,3,3,3,3,3], 1)
[ i, t, d, temp1,temp2,temp3,temp4,temp5,temp6] = Dalg.run(150,1)'''

# to generate figure 2 (right) in the paper, uncomment the following and run the python code
'''Dalg = DetectAlgo(1,1,[[-2,-0.5,-0.1],[2,5,1]],[1, 0, 0.05], 2, 0.5, 9, [Glycemic,Glycemic1, Glycemic2,Glycemic3,Glycemic4,Glycemic5,Glycemic6,Glycemic7,Glycemic8],[3,3,3,3,3,3,3,3,3], 1)
[ i, t, d, temp1,temp2,temp3,temp4,temp5,temp6] = Dalg.run(150,1)'''

# to generate figure 2 (left) in the paper, uncomment the following and run the python code
'''Dalg = DetectAlgo(0.1,1,[[-5,-5,-5,-5,-5],[5,5,5,5,5]],[3.1, 4, 0,0,0], 2, 0.5, 2, [sys8,sys9,sys10,sys11,sys12],[L8,L9,L10,L11,L12], 0)
[i, t, d, temp1,temp2,temp3,temp4, temp5, temp6] = Dalg.run(60,1)
print "N: ", 1
print "deltamax", temp1
print "numSwitches", temp2
print "numEscapes", temp3
print "Dmax", temp4
print "max_i_tau", temp5
print "assumption2_violated", temp6'''


'''deltamaxSum = 0
numEscapesSum = 0
numSwitchesSum = 0
DmaxSum = 0
tauSum = 0
assumption2_violatedSum = 0
for N in range(1,10):
    deltamaxSum = 0
    numEscapesSum = 0
    numSwitchesSum = 0
    DmaxSum = 0
    for j in range(0, 100):
        x0 = [np.random.uniform(-1.5,1.5), 0, np.random.uniform(-0.1,0.1)]
        Dalg = DetectAlgo(1,1,[[-2,-0.5,-0.1],[2,5,1]],x0, 2, 0.5, N, [Glycemic,Glycemic1, Glycemic2,Glycemic3,Glycemic4,Glycemic5,Glycemic6,Glycemic7,Glycemic8],[3,3,3,3,3,3,3,3,3], 2)
        [i, t, d, temp1,temp2,temp3,temp4,temp5, temp6] = Dalg.run(150,0)
        deltamaxSum = deltamaxSum + temp1
        numSwitchesSum = numSwitchesSum + temp2
        numEscapesSum = numEscapesSum + temp3
        DmaxSum = DmaxSum + temp4
        tauSum = tauSum + temp5
        assumption2_violatedSum = assumption2_violatedSum + temp6
    print "N: ", N
    print "deltamax", deltamaxSum/100
    print "numEscapes", numEscapesSum/100.0
    print "numSwitches", numSwitchesSum/100.0
    print "Dmax", DmaxSum/100.0
    print "tauSum", tauSum/100.0
    print "assumption2_violated", assumption2_violatedSum/100.0'''